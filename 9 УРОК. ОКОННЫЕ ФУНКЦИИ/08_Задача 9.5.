### Задача 5.

---

В предыдущих заданиях в качестве окна выступала вся таблица. Теперь давайте научимся добавлять в параметры окна деление на партиции и поработаем с инструкцией `PARTITION BY`.

---

**Задание:**

Для каждого пользователя в таблице `user_actions` посчитайте порядковый номер каждого заказа.

Для этого примените оконную функцию `ROW_NUMBER` к колонке с временем заказа. Не забудьте указать деление на партиции по пользователям и сортировку внутри партиций. Отменённые заказы не учитывайте.

Новую колонку с порядковым номером заказа назовите `order_number`. Результат отсортируйте сначала по возрастанию id пользователя, затем по возрастанию порядкового номера заказа.

Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

---

Поля в результирующей таблице: `user_id`, `order_id`, `time`, `order_number`

---

 **Ожидаемый результат**

|user_id|order_id|time|order_number|
|---|---|---|---|
|1|1|2022-08-24 01:52:21|1|
|1|4683|2022-08-27 20:56:31|2|
|1|22901|2022-09-02 00:58:40|3|
|1|23149|2022-09-02 02:36:41|4|
|2|2|2022-08-24 06:37:57|1|
|...|...|...|...|
|141|153|2022-08-25 00:09:09|1|
|141|3458|2022-08-27 10:00:57|2|
|141|4515|2022-08-27 19:47:12|3|
|141|4525|2022-08-27 19:49:50|4|
|141|46568|2022-09-06 11:09:55|5|
|...|...|...|...|
|248|13935|2022-08-30 17:13:00|8|
|248|15518|2022-08-31 02:25:44|9|
|249|287|2022-08-25 03:54:33|1|
|249|758|2022-08-25 15:19:05|2|
|249|7347|2022-08-28 19:27:34|3|

Affected rows: 1000

---

# Решения:

## Мое решение:
```
SELECT user_id, order_id, time, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY time) as order_number
FROM user_actions
WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
ORDER BY user_id, order_id
LIMIT 1000
```

## Решение Автора:
```
совпадает
```
