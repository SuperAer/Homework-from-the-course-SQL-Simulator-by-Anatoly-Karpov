### Задача 6.

---

Теперь поработаем с функциями смещения — в этом тоже нет ничего сложного:

```
SELECT LAG(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lag_value
FROM table

SELECT LEAD(column, 1) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS lead_value
FROM table
```

В качестве первого аргумента у функций `LAG` и `LEAD` указывается колонка со значениями, в качестве второго — то, на какое число строк производить смещение (назад и вперёд соответственно). Второй аргумент можно не указывать, по умолчанию его значение равно 1.

---

**На заметку:**

Подробнее про функции `LAG` и `LEAD` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-window-function/postgresql-lag-function/) и [здесь](https://www.postgresqltutorial.com/postgresql-window-function/postgresql-lead-function/).

---

**Задание:**

Дополните запрос из предыдущего задания и с помощью оконной функции для каждого заказа каждого пользователя рассчитайте, сколько времени прошло с момента предыдущего заказа. 

Для этого сначала в отдельном столбце с помощью `LAG` сделайте смещение по столбцу `time` на одно значение назад. Столбец со смещёнными значениями назовите `time_lag`. Затем отнимите от каждого значения в колонке `time` новое значение со смещением (либо можете использовать уже знакомую функцию `AGE`). Колонку с полученным интервалом назовите `time_diff`. Менять формат отображения значений не нужно, они должны иметь примерно следующий вид:

```
3 days, 12:18:22
```

По-прежнему не учитывайте отменённые заказы. Также оставьте в запросе порядковый номер каждого заказа, рассчитанный на прошлом шаге. Результат отсортируйте сначала по возрастанию id пользователя, затем по возрастанию порядкового номера заказа.

Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: `user_id`, `order_id`, `time`, `order_number`, `time_lag`, `time_diff`

---

**Пояснение:**

Не забывайте про деление на партиции и сортировку внутри окна.

Также обратите внимание, что в результате смещения для первых заказов каждого пользователя в колонке `time_lag` получились пропущенные значения. Для таких записей функция не нашла предыдущих значений и вернула `NULL`. То же самое произошло в записях пользователей с одним заказом — внутри партиции с одной записью просто некуда сдвигаться.

Образовавшиеся пропущенные значения убирать из результата не нужно.

---

 **Ожидаемый результат**

|user_id|order_id|time|order_number|time_lag|time_diff|
|---|---|---|---|---|---|
|1|1|2022-08-24 01:52:21|1|||
|1|4683|2022-08-27 20:56:31|2|2022-08-24 01:52:21|3 days 19:04:10|
|1|22901|2022-09-02 00:58:40|3|2022-08-27 20:56:31|5 days 04:02:09|
|1|23149|2022-09-02 02:36:41|4|2022-09-02 00:58:40|0 days 01:38:01|
|2|2|2022-08-24 06:37:57|1|||
|...|...|...|...|...|...|
|141|153|2022-08-25 00:09:09|1|||
|141|3458|2022-08-27 10:00:57|2|2022-08-25 00:09:09|2 days 09:51:48|
|141|4515|2022-08-27 19:47:12|3|2022-08-27 10:00:57|0 days 09:46:15|
|141|4525|2022-08-27 19:49:50|4|2022-08-27 19:47:12|0 days 00:02:38|
|141|46568|2022-09-06 11:09:55|5|2022-08-27 19:49:50|9 days 15:20:05|
|...|...|...|...|...|...|
|248|13935|2022-08-30 17:13:00|8|2022-08-30 11:04:07|0 days 06:08:53|
|248|15518|2022-08-31 02:25:44|9|2022-08-30 17:13:00|0 days 09:12:44|
|249|287|2022-08-25 03:54:33|1|||
|249|758|2022-08-25 15:19:05|2|2022-08-25 03:54:33|0 days 11:24:32|
|249|7347|2022-08-28 19:27:34|3|2022-08-25 15:19:05|3 days 04:08:29|

Affected rows: 1000

---

# Решения:

## Мое решение:
```
SELECT 
    user_id, order_id, time, 
    ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY time) as order_number,
    LAG(time,1) OVER(PARTITION BY user_id ORDER BY time) as time_lag,
    time - LAG(time,1) OVER(PARTITION BY user_id ORDER BY time) as time_diff
FROM user_actions
WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
ORDER BY user_id, order_number
LIMIT 1000
```

## Решение Автора:
```
совпадает
```
