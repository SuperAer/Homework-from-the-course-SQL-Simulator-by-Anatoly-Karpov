### Задача 8.

---

Пришло время немного поработать с инструкцией `ROWS BETWEEN`, которую мы подробно рассматривали на первом шаге. Напомним, что начало и конец рамки задаются следующими способами:

```
UNBOUNDED PRECEDING
значение PRECEDING
CURRENT ROW
значение FOLLOWING
UNBOUNDED FOLLOWING
```

---

Вот ещё один пример указания границ рамки:

```
SELECT SUM(column_3) OVER (PARTITION BY column_1 
                           ORDER BY column_2 
                           ROWS BETWEEN UNBOUNDED PRECEDING AND 3 FOLLOWING) AS sum
FROM table
```

---

Но в каких задачах бывает полезно указывать рамку для расчётов? Первое, что приходит на ум любому аналитику, — скользящее среднее.

Скользящее среднее — это показатель, который вычисляется в каждой точке временного ряда как среднее значение за N предыдущих периодов (дней, недель, месяцев и т.д. в зависимости от уровня агрегации данных). Скользящее среднее как бы перемещается по временному ряду и каждый раз учитывает фиксированное количество значений — для проведения таких расчётов как раз и нужна рамка окна, которая задаётся инструкцией `ROWS BETWEEN`.

Давайте попробуем провести такие расчёты на наших данных.

---

**Задание:**

Сначала на основе таблицы `orders` сформируйте новую таблицу с общим числом заказов по дням. Вы уже делали это в одной из [предыдущих задач](https://lab.karpov.courses/learning/152/module/1762/lesson/17930/53221/260813/). При подсчёте числа заказов не учитывайте отменённые заказы (их можно определить по таблице `user_actions`). Колонку с числом заказов назовите `orders_count`.

Затем поместите полученную таблицу в подзапрос и примените к ней оконную функцию в паре с агрегирующей функцией `AVG` для расчёта скользящего среднего числа заказов. Скользящее среднее для каждой записи считайте по трём предыдущим дням. Подумайте, как правильно задать границы рамки, чтобы получить корректные расчёты.

Полученные значения скользящего среднего округлите до двух знаков после запятой. Колонку с рассчитанным показателем назовите `moving_avg`. Сортировку результирующей таблицы делать не нужно.

Поля в результирующей таблице: `date`, `orders_count`, `moving_avg`

---

**Пояснение:**

При решении задачи можете пробовать разные границы рамки и проверять себя вручную. Важно для каждой даты учесть в расчётах именно 3 предыдущих дня.

Заполнять пропущенные значения в этой задаче не нужно. Подумайте, почему они могли появиться.

---

 **Ожидаемый результат**

|date|orders_count|moving_avg|
|---|---|---|
|2022-08-24|138||
|2022-08-25|1059|138.0|
|2022-08-26|1447|598.5|
|2022-08-27|2141|881.33|
|2022-08-28|2998|1549.0|
|...|...|...|
|2022-08-30|3371|2802.0|
|2022-08-31|3410|3212.0|
|2022-09-01|3688|3349.33|
|2022-09-02|5001|3489.67|
|2022-09-03|5709|4033.0|
|...|...|...|
|2022-09-04|6010|4799.33|
|2022-09-05|4675|5573.33|
|2022-09-06|3451|5464.67|
|2022-09-07|4777|4712.0|
|2022-09-08|5474|4301.0|

Affected rows: 16

---

# Решения:

## Мое решение:
```
SELECT date,
       orders_count,
       round(avg(orders_count) OVER (ORDER BY date rows between 3 preceding and 1 preceding),
             2) as moving_avg
FROM   (SELECT creation_time:: date as date,
               count(order_id) as orders_count
        FROM   orders
        WHERE  order_id not in (SELECT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')
        GROUP BY date
        ORDER BY date) t
```

## Решение Автора:
```
SELECT date,
       orders_count,
       round(avg(orders_count) OVER (ORDER BY date rows between 3 preceding and 1 preceding),
             2) as moving_avg
FROM   (SELECT date(creation_time) as date,
               count(order_id) as orders_count
        FROM   orders
        WHERE  order_id not in (SELECT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')
        GROUP BY date) t
```
