### Задача 4.

---

Теперь применим оконную функцию с инструкцией `ORDER BY` для решения практической задачи.

Как мы помним из первого шага, указание сортировки задаёт рамку окна от начала таблицы или партиции до текущей строки. Давайте используем эту особенность для расчёта накопительной суммы, т.е. сделаем так, чтобы для каждой записи возвращался результат сложения её значения со значениями всех предыдущих записей.

---

**Задание:**

Сначала на основе таблицы `orders` сформируйте новую таблицу с общим числом заказов по дням. При подсчёте числа заказов не учитывайте отменённые заказы (их можно определить по таблице `user_actions`). Колонку с днями назовите `date`, а колонку с числом заказов — `orders_count`.

Затем поместите полученную таблицу в подзапрос и примените к ней оконную функцию в паре с агрегирующей функцией `SUM` для расчёта накопительной суммы числа заказов. Не забудьте для окна задать инструкцию `ORDER BY` по дате.

Колонку с накопительной суммой назовите `orders_cum_count`. В результате такой операции значение накопительной суммы для последнего дня должно получиться равным общему числу заказов за весь период.

Сортировку результирующей таблицы делать не нужно.

Поля в результирующей таблице: `date`, `orders_count`, `orders_cum_count`

---

**Пояснение:**

Обратите внимание, что в PostgreSQL оконные функции в качестве результата возвращают значение типа `DECIMAL` несмотря на то, что исходное значение находится в формате `INTEGER`. Поэтому не забудьте полученное значение накопительной суммы дополнительно привести к целочисленному формату.

---

 **Ожидаемый результат**

|date|orders_count|orders_cum_count|
|---|---|---|
|2022-08-24|138|138|
|2022-08-25|1059|1197|
|2022-08-26|1447|2644|
|2022-08-27|2141|4785|
|2022-08-28|2998|7783|
|...|...|...|
|2022-08-30|3371|14421|
|2022-08-31|3410|17831|
|2022-09-01|3688|21519|
|2022-09-02|5001|26520|
|2022-09-03|5709|32229|
|...|...|...|
|2022-09-04|6010|38239|
|2022-09-05|4675|42914|
|2022-09-06|3451|46365|
|2022-09-07|4777|51142|
|2022-09-08|5474|56616|

Affected rows: 16

---

# Решения:

## Мое решение:
```
SELECT date, orders_count, SUM(orders_count) OVER(ORDER BY date)::INTEGER as orders_cum_count
FROM (
    SELECT creation_time::DATE AS date, COUNT(order_id) as orders_count
    FROM orders
    WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
    GROUP BY date
) t
```

## Решение Автора:
```
совпадает
```
