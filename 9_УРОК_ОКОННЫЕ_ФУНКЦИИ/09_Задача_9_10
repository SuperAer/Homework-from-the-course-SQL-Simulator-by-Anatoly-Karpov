
### Задача 10. 

**НОВАЯ ЗАДАЧА**

Теперь, вооружившись новыми знаниями, вернёмся к расчёту первых и повторных заказов. Попробуем с помощью оконных функций и конструкции `CASE` посчитать сразу в одном запросе и те, и другие, не применяя `JOIN`.

---

**Задание:**

По данным таблицы `user_actions` посчитайте число первых и повторных заказов на каждую дату.

Для этого сначала с помощью оконных функций и оператора `CASE` сформируйте таблицу, в которой напротив каждого заказа будет стоять отметка `«Первый»` или `«Повторный»` (без кавычек). Для каждого пользователя первым заказом будет тот, который был сделан раньше всего. Все остальные заказы должны попасть, соответственно, в категорию `«Повторный»`. Затем на каждую дату посчитайте число заказов каждой категории.

Колонку с типом заказа назовите `order_type`, колонку с датой — `date`, колонку с числом заказов — `orders_count`.

В расчётах учитывайте только неотменённые заказы.

Результат отсортируйте сначала по возрастанию даты, затем по возрастанию значений в колонке с типом заказа.

Поля в результирующей таблице: `date`, `order_type`, `orders_count`

---

**Пояснение:**

Таблицу с первыми и повторными заказами необходимо сформировать на основе таблицы `user_actions`. Предполагается, что у каждого пользователя должен быть один первый заказ. Но если случается так, что по каким-то причинам два наиболее ранних заказа оформляются в одно и то же время, то оба считаем первыми.

В этой задаче использовать `JOIN` не нужно, достаточно правильно применить `CASE` и оконную функцию.

При использовании оконных функций помните, что первые заказы необходимо определить для каждого пользователя, а не для всех пользователей сразу. Также обратите внимание, что отменённые заказы в этой задаче мы не учитываем.

---

 **Ожидаемый результат**

|date|order_type|orders_count|
|---|---|---|
|24/08/22|Первый|127|
|24/08/22|Повторный|11|
|25/08/22|Первый|802|
|25/08/22|Повторный|257|
|26/08/22|Первый|985|
|...|...|...|
|31/08/22|Первый|1380|
|31/08/22|Повторный|2030|
|01/09/22|Первый|1492|
|01/09/22|Повторный|2196|
|02/09/22|Первый|1865|
|...|...|...|
|06/09/22|Повторный|2438|
|07/09/22|Первый|1419|
|07/09/22|Повторный|3358|
|08/09/22|Первый|1661|
|08/09/22|Повторный|3813|

Affected rows: 32

---

 **Подсказка**

Решить задачу можно разными способами. Можно сначала для каждого пользователя отранжировать все его заказы по дате и определить самые первые, а можно определить самую первую отметку времени и в операторе CASE сравнить её со всеми отметками времени, определив таким образом самые первые заказы. После того как заказы будут разделены на первые и повторные, необходимо просто правильно сгруппировать данные и посчитать число заказов в каждой группе на каждую дату.

---



# Решения:

## Мое решение:
```
SELECT date,
       order_type,
       count(order_type) as orders_count
FROM   (SELECT date(time) as date,
               user_id,
               order_id,
               rank() OVER(PARTITION BY user_id
                           ORDER BY time) as rank,
               case when rank() OVER(PARTITION BY user_id
                                     ORDER BY time) = 1 then 'Первый'
                    else 'Повторный' end as order_type
        FROM   user_actions
        WHERE  order_id not in (SELECT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')) t
GROUP BY date, order_type
ORDER BY date, order_type
```

## Решение Автора:
```
SELECT time::date as date,
       order_type,
       count(order_id) as orders_count
FROM   (SELECT user_id,
               order_id,
               time,
               case when time = min(time) OVER (PARTITION BY user_id) then 'Первый'
                    else 'Повторный' end as order_type
        FROM   user_actions
        WHERE  order_id not in (SELECT order_id
                                FROM   user_actions
                                WHERE  action = 'cancel_order')) t
GROUP BY date, order_type
ORDER BY date, order_type
```
