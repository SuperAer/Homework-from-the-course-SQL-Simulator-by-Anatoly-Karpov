### * Задача 19.

---

На днях менеджер снова обратился к вам с задачей: попросил сделать выгрузку из таблицы `orders` со всеми заказами и их содержимым. Из переписки вы так и не поняли, зачем ему все эти данные, но задачу сделали: нажали `SELECT *` и отправили ему excel-файл с заказами. На следующее утро выяснилось, что такие данные его не устраивают, так как он не понимает, что это за списки с наборами чисел. Действительно, этот момент вы не учли. Давайте исправляться!

---

**Задача:**

Произведите замену списков с id товаров из таблицы `orders` на списки с наименованиями товаров. Наименования возьмите из таблицы `products`. Колонку с новыми списками наименований назовите `product_names`. 

Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: `order_id`, `product_names`

---

**Пояснение:**

Для решения задачи вам нужно сделать `unnest` колонки `product_ids`, соединить промежуточный результат с таблицей `products` для получения наименований товаров, а затем сделать обратно группировку с агрегацией в список наименований. 

Для того чтобы сделать агрегацию значений в колонке в список, необходимо воспользоваться функцией `array_agg`.

`array_agg` — это продвинутая агрегирующая функция, которая собирает все значения в указанном столбце в единый список (`ARRAY`). По сути `array_agg` — это операция, обратная `unnest`, её синтаксис ничем не отличается от синтаксиса остальных агрегирующих функций:

SELECT column_1, array_agg(column_2) AS new_array FROM table GROUP BY column_1

Перед тем как решать задачу, попробуйте сначала выполнить простое упражнение: разверните списки с id товаров, поместите результат в подзапрос, а потом сразу же сверните всё обратно в списки с помощью `array_agg`. Алгоритм решения этой задачи примерно такой же.

---

**На заметку:**

Подробнее про функцию `array_agg` можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-aggregate-functions/postgresql-array_agg/).

---

 **Ожидаемый результат**

|order_id|product_names|
|---|---|
|1|['бананы', 'сливки']|
|2|['энергетический напиток', 'лимонад', 'горох', 'макароны']|
|3|['сок апельсиновый', 'масло подсолнечное', 'курица']|
|4|['груши', 'хлеб', 'батон']|
|5|['иван-чай в пакетиках']|
|...|...|
|499|['лимонад', 'курица']|
|500|['хлеб', 'вода негазированная', 'баранина']|
|501|['сушки', 'свинина', 'чай зеленый в пакетиках']|
|502|['свинина', 'мука', 'мандарины', 'печенье']|
|503|['вода негазированная', 'хлеб', 'чай зеленый в пакетиках']|
|...|...|
|996|['яблоки', 'сок мультифрукт', 'соль', 'рис']|
|997|['сосиски']|
|998|['печенье', 'макароны', 'чай черный листовой', 'мандарины', 'хлеб']|
|999|['энергетический напиток', 'молоко', 'чай зеленый в пакетиках', 'сгущенка']|
|1000|['уксус', 'сгущенка']|

Affected rows: 1000

---

# Решения:

## Мое решение:

SELECT order_id, array_agg(name) AS product_names
FROM 
    (SELECT order_id, unnest(product_ids) AS product_id
    FROM orders
    ) t1 LEFT JOIN products USING(product_id)

GROUP BY order_id
LIMIT 1000

## Решение от Автора курса:

SELECT order_id,
       array_agg(name) as product_names
FROM   (SELECT order_id,
               unnest(product_ids) as product_id
        FROM   orders) t join products using(product_id)
GROUP BY order_id limit 1000
